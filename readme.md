# 헤드퍼스트의 디자인 패턴


읽은 이유 : 

"오브젝트" 책을 읽은 후에야 디자인 패턴의 의미를 깨달았다. 코딩하면서 디자인 패턴을 자주 썼겠지만, 그게 왜 필요한지 명확히 이해하지 못했다. 
그런데 이 책을 통해 그 이유를 알 수 있게한다.. 이제는 패턴을 무작정 적용하는 게 아니라 상황에 맞게 활용할 줄 알길 원했다., 오픈소스 코드에서도 패턴을 더 잘 파악할 수 있게 될 거 같다.
가장 중요한 건, 디자인 패턴이 코드를 읽기 쉽고 유지 보수하기 쉽게 만들어 준다는 것이다. "오브젝트" 책에서는 이론적인 내용이 많았지만, 객체지향을 다루면서 디자인 패턴을 실제로 적용하는 과정을 배울 수 있어서 기대된다.
결국에는 더 나은 코드를 작성하고 유지 보수할 수 있는 능력을 키울 수 있다는 기대감으로 이 책을 읽는다.


챕터 1 디자인 패턴 소개와 전략 패턴
-
>  객체들이 할 수 있는 행위 각각에 대해 전략 클래스를 생성하고, 유사한 행위들을 캡슐화 하는 인터페이스를 정의하여,
객체의 행위를 동적으로 바꾸고 싶은 경우 직접 행위를 수정하지 않고 전략을 바꿔주기만 함으로써 행위를 유연하게 확장하는 방법을 말합니다.

전략 패턴은 다음 세 가지 주요 구성 요소로 이루어져 있습니다

Context: 전략을 사용하는 역할을 하는 클래스입니다. 이 클래스가 다양한 전략 중에서 적절한 전략 객체를 선택하고 사용합니다.

Strategy: 모든 전략이 공통으로 가져야 할 인터페이스이며, Context가 사용할 수 있게 메서드를 제공합니다.

Concrete Strategy: Strategy 인터페이스를 구현하는 실제 전략 클래스입니다.

오리의 상속관계 구현을 통해 상속의 문제점을 짚는걸로 시작한다.
상속이 재사용 관점에서 사용되다보니, 사이드 이펙트 문제를 낳는다. 이 문제를 해결하기 위해 fly를 추상화하여 구현하는 방식으로 변경하였으나
구현해야할 구현체가 100개 이상이라면 어떻게 할 것인가? 하는 고민을 하게된다. 이 문제를 해결하기위해 협력이라는 관점에서 소유의 개념으로 변경된 코드를 보여주며
소위 "모듈화" 개념을 구현하여 보여주었다. 이렇게 했을때, 변경에는 닫혀있고 확장에는 열려있는 OCP원칙을 지킬 수 있게되었다.
이때 3가지 디자인 원칙을 말하는데 아래와 같다.
1. 애플리케이션에서 달라지는 부분을 찾아내고, 달라지지 않는 부분과 분리한다.
2. 구현보다는 인터페이스에 맞춰서 프로그래밍 한다.
3. 상속보다는 구성을 활용한다. (COMPOSITION)

위와 같이 오리의 행위하나 나누어 알고리즘군을 정의하고 캡슐화여하여 사용하는것 이를 "전략패턴"이라한다.

챕터 2 객체들에게 연락돌리기 옵저버 패턴
-
> 한 객체가 상태가 바뀌면 그 객체에 의존하는 다른 객체에게 연락이 가고 자동으로 내용이 갱신되는 방식으로 일대다 의존성을 정의한다.

옵저버 패턴은 다음 요소로 구성됩니다

Subject: 상태가 변경될 때마다 그 사실을 Observer들에게 알려주는 객체입니다. Observer들을 등록하고 삭제하는 메서드를 포함하며, 상태가 변경될 때마다 Observer들에게 알리는 메서드를 가지고 있습니다.

Observer: Subject의 상태 변화를 관찰하는 객체들입니다. Subject에서 알림을 받을 때마다 특정한 작업을 수행하는 메서드를 구현합니다.

ConcreteSubject: 실제 상태를 가진 Subject이며, Observer들에게 알림을 보내는 메서드를 구현합니다.

ConcreteObserver: Observer 인터페이스를 구현하는 객체로, ConcreteSubject의 상태 변화에 따른 적절한 동작을 수행합니다.

백화점 식당의 주문현황판을 본적이 있는가? 사용자가 주문하면 해당 하는 주문번호가 생성되고 현황판에 주문대기란에 노출된다.
그러다 식당주인이 요리가 다 되었으면 주문이 다 되었다고 현황판을 업데이트 시킨다. 
이럴때 패턴을 적용시키지 않고 구현한다면, 각 디스플레이마다 상태 업데이트 메세지를 보내야 할 것이다.
그러나 옵저버 패턴은 특정 상태에 대해 변경이 감지 되면 업데이트 되게 한다. 말로는 이해가 잘안된다. 
책에서 구현한 날씨 관련 앱과 응용하여 주문현황판 업데이트 앱을 만들어보자.


옵저버 패턴 모양이 생소하다. 이런데도 객체지향의 원칙과 일치하는가? 한번 알아보자

1. 애플리케이션에서 달라지는 부분을 찾아내고, 달라지지 않는 부분과 분리한다. 
-> 옵저버 패턴에서 변하는 것은 주제와 상태 옵저버의 개수, 형식이다.
2. 구현보다는 인터페이스에 맞춰서 프로그래밍 한다.
-> 주제를 Subject로 Observer 인터페이스를 활용하여 구현하였고, 주제는 구독자를 알지 못한다. 즉, 추상화를 의존했다.
3. 상속보다는 구성을 활용한다. (COMPOSITION)
-> 옵저버를 구현한 구현체는 구독할 주제를 has - a 방식인 구성을 이용했다.

옵저버에서도 객체지향 원칙이 잘 지켜지고 있음을 알 수 있다.

챕터 3 객체 꾸미기 데코레이터 패턴
- 
> 객체의 기능을 동적으로 추가하거나 수정할 수 있게 하는 패턴, 이 패턴은 기본적인 객체에 추가적인 기능을 부여하는 역할을 하는 데코레이터 객체를 사용한다. 데코레이터 객체는 원본 객체와 같은 인터페이스를 갖으며, 원본 객체에 추가적인 작업을 추가하거나 오버라이드하여 본질적으로 객체의 행동을 확장합니다.

데코레이터 패턴은 다음중 주요 요소들로 구성됩니다

Component: 이것은 기본 인터페이스이며, 데코레이터와 구체적인 구성 요소 모두 이것을 구현합니다. 이것은 우리가 데코레이터를 통해 확장하려는 기본 객체의 기능을 정의합니다.

ConcreteComponent: 이것은 Component 인터페이스를 구현하는 클래스로서, 데코레이터를 적용할 기본 객체입니다.

Decorator: 이것은 Component를 감싸는 클래스입니다. 이것은 자기 자신이 Component 인터페이스를 구현하며, 또한 Component 객체를 가지고 있어 그 객체의 메서드를 호출할 수 있습니다. 이 클래스의 목적은 메서드를 오버라이드하거나 추가하여 기본 객체의 기능을 확장하는 것입니다.

ConcreteDecorator: 이것은 특정 종류의 데코레이션 동작을 정의하는 Decorator의 서브클래스입니다. 이 클래스의 인스턴스는 실행 시간에 Component(또는 다른 ConcreteDecorator)에 추가 될 수 있습니다. 

스타벅스의 음료 메뉴를 예시로 들어 설명해보겠습니다. 스타벅스의 음료 메뉴는 주로 커피나 티를 기본으로 하고, 고객은 여러 옵션을 추가할 수 있습니다. 이때, 상속보다는 데코레이터 패턴을 사용하는 것이 효과적입니다.

데코레이터 패턴은 객체의 행동을 확장하거나 변경할 수 있게 해줍니다. 예를 들어, 아메리카노는 스타벅스의 주요 음료 중 하나입니다. 이를 기본으로 하고, 고객이 시럽을 추가하거나 휘핑 크림을 올릴 수 있습니다.

이 경우, 아메리카노를 나타내는 클래스에는 기본적인 아메리카노의 특성과 행동이 정의됩니다. 그리고 시럽이나 휘핑 크림을 추가하는 것은 데코레이터 클래스로 구현됩니다. 이 데코레이터 클래스는 아메리카노 객체를 소유하고 있으며, 해당 객체에 시럽을 추가하거나 휘핑 크림을 올리는 등의 행동을 정의합니다.

이렇게 하면 기본 객체를 수정하지 않고도 필요한 기능을 추가하거나 변경할 수 있습니다. 또한, 데코레이터 패턴은 중첩되어 여러 옵션을 추가할 수 있으며, 이는 코드를 깔끔하게 유지하면서도 유연성을 제공합니다.

이러한 데코레이터 패턴의 개념은 자바의 IO 스트림에서도 사용됩니다. 예를 들어, FilterInputStream은 추상 데코레이터 클래스로, 이를 상속하여 특정 입력 스트림에 필터를 추가할 수 있습니다. 이를 통해 데이터를 처리하거나 변환하는 등의 작업을 수행할 수 있습니다.

헤드퍼스트의 예제를 보면 Beverage가 추상클래스로 구현되어 있으나 이는 인터페이스로 구현해도 되긴하다.

데코레이터 패턴도 결국 데코레이터 객체를 구현하려면 상속이나 구현을 통해 만들어야하는게 아닌지 의문이 들수 있다.
이는 행동을 상속받으려 한것이 아니라 꾸밀객체의 형식을 상속받은 것임을 명심하자.

문제점
1. 데코레이터가 많아지면 코드가 필요이상으로 복잡해 질 수 있다.
2. 클라이언트는 데코레이터를 사용한다는 사실을 전혀 모르기 때문에 특정형식에 의존한 코드에 적용시 예기치 못한 문제가 발생할 수 있다.

챕터 4 객체지향 빵 굽기 팩토리 패턴
- 
> 팩토리 패턴은 객체 생성에 관련된 디자인 패턴입니다. 이 패턴은 객체를 생성하는 인터페이스를 정의하지만, 어떤 클래스의 인스턴스를 생성할지는 서브 클래스에게 결정하도록 합니다. 이렇게 하여 코드의 유연성을 높이고, 클래스 간의 결합도를 줄여줍니다.

팩토리 패턴은 기본적으로 세 가지로 구성됩니다.

Product: 팩토리 메서드가 생성해야 할 객체의 인터페이스입니다.

ConcreteProduct: Product 인터페이스를 구현한 클래스로, 실제 생성되는 객체입니다.

Creator: Product 객체를 생성하는 메서드(factory method)를 선언하는 클래스나 인터페이스입니다.

팩토리 패턴은 생성관련 의존성을 관리하고자 하는 패턴이다. 생성하는 부분을 전략패턴과 같이 구성으로 사용한다면 단지 "팩토리" 라고 하며 어떤 클래스의 객체 생성부분을 메소드로 분리하면
팩토리 메소드 패턴, 객체로 분류하면 추상 팩토리 패턴이라고 한다. 예제에서 Pizza가 만들어질때 일련의 제품을 만드는 과정을 팩터리한 PizzaIngredientFactory는 추상 팩토리 패턴이며,
PizzaStore를 구현한 NYPizzaStore 가 구현한 createPizza 메소드는 팩토리 메소드이다.

팩토리 메소드 패턴 : 팩토리 메소드 패턴은 서브클래스가 어떤 객체를 생성할 지 결정하도록 합니다. 즉, 클래스의 인스턴스를 만드는 시간과 방법을 서브클래스로 위임하는 방법입니다. 이 패턴은 메소드를 이용하여 객체를 생성하는 인터페이스를 정의합니다. 객체의 생성은 서브클래스에서 수행됩니다.

추상 팩토리 패턴 : 추상 팩토리 패턴은 관련성이 있는 여러 객체를 생성할 수 있는 인터페이스를 제공합니다. 이 패턴에서는 구체 클래스를 명시하지 않고 관련된 객체의 그룹을 생성할 수 있는 상위 수준의 인터페이스를 제공합니다.

챕터 5 하나뿐인 특별한 객체 만들기 싱글턴 패턴
- 
> 클래스 인스턴스를 하나만 만들고, 그 인스턴스로의 전역 접근을 제공합니다.

싱글톤 패턴은 Spring의 Component를 사용했다면 익숙한 패턴이다. 인스턴스가 두개 이상 생성되지 않으며 전역으로 사용할 수 있는 객체를 만드는 것이 핵심이다.
이때에 여러가지 문제를 낳는데 이를 해결하는 방법을 알려준다.
```java
public static SingleTon getInstance() {
    if (uniqueInstance == null) {
        uniqueInstance = new Singleton();
    }
    return uniqueInstance;
}
```
위 코드는 싱글톤 객체를 생성하기 위한 함수인데, 2개 이상의 쓰레드가 접근할 경우 2개이상의 데이터가 생성될 수 있다는 단점이 있다.
이를 해결하기 위해 3가지를 나열한다.
1. 속도가 중요하지 않다면 syncronized 예약어를 사용하여 동기화 처리한다.
2. 인스턴스 사용주기가 처음 부터 끝까지 사용한다면 처음부터 생성하고 사용하는것도 방법이다.
3. syncronized 와 volatile 예약어를 사용하여 성능을 생각한 메소드로 만들 수 있다.

챕터 6 호출캡슐화하기 커맨드 패턴
-
> 커맨드 패턴은 요구 사항을 캡슐화하여 다른 객체에 매개변수로 전달하는 패턴이다. 

커맨드 패턴의 구성요소는 다음과 같다.

Command 인터페이스: 모든 구체적인 커맨드들이 이 인터페이스를 구현합니다. 주로 실행 메서드가 정의됩니다.

Concrete Command: Command 인터페이스를 구현하는 클래스이며, 실제로 실행되는 로직인 Receiver를 가지고 있습니다.

Receiver: 실제 로직이 구현된 객체입니다. Concrete Command 객체가 이 객체를 이용해서 실제 작업을 수행합니다.

Invoker: 클라이언트에서 요청을 받아, 해당 요청을 처리할 Concrete Command 객체를 생성하고 실행합니다.

이는 객체지향과 연관지어 생각했을때 부합하다. 

캡슐화: 커맨드 패턴에서는 작업을 수행하는 로직을 캡슐화합니다. 각 커맨드는 특정 작업이나 요청에 특화된 기능을 갖는 객체로, 요청의 발신자와 수신자를 분리함으로써 각 객체의 역할을 세분화하고 결합도를 낮춥니다.

단일 책임 원칙: 커맨드 패턴은 별도의 커맨드 객체를 통해 작업의 실행이라는 특정 책임을 분리합니다. 각 커맨드 객체는 자신의 작업 실행에만 집중하며, 이는 단일 책임 원칙을 지킵니다.

열림-폐쇄 원칙: 커맨드 패턴은 기존 코드를 변경하지 않고도 새로운 기능을 추가하는 데 유리합니다. 새로운 커맨드를 추가하려면 Command 인터페이스를 구현하는 새 클래스만 생성하면 됩니다, 이는 열림-폐쇄 원칙을 따릅니다.

의존성 역전 원칙: 커맨드 패턴에서는 상위 수준의 모듈(Invoker)이 하위 수준의 모듈(Concrete Commands)에 직접 의존하지 않습니다. 대신 Invoker는 Command 인터페이스에 의존하며, 이 인터페이스는 필요한 모든 메서드를 정의하고 있어 이를 구현한 어떤 객체와도 상호작용할 수 있습니다.