# 헤드퍼스트의 디자인 패턴


읽은 이유 : 

"오브젝트" 책을 읽은 후에야 디자인 패턴의 의미를 깨달았다. 코딩하면서 디자인 패턴을 자주 썼겠지만, 그게 왜 필요한지 명확히 이해하지 못했다. 
그런데 이 책을 통해 그 이유를 알 수 있게한다.. 이제는 패턴을 무작정 적용하는 게 아니라 상황에 맞게 활용할 줄 알길 원했다., 오픈소스 코드에서도 패턴을 더 잘 파악할 수 있게 될 거 같다.
가장 중요한 건, 디자인 패턴이 코드를 읽기 쉽고 유지 보수하기 쉽게 만들어 준다는 것이다. "오브젝트" 책에서는 이론적인 내용이 많았지만, 객체지향을 다루면서 디자인 패턴을 실제로 적용하는 과정을 배울 수 있어서 기대된다.
결국에는 더 나은 코드를 작성하고 유지 보수할 수 있는 능력을 키울 수 있다는 기대감으로 이 책을 읽는다.


챕터 1 디자인 패턴 소개와 전략 패턴
-
>  객체들이 할 수 있는 행위 각각에 대해 전략 클래스를 생성하고, 유사한 행위들을 캡슐화 하는 인터페이스를 정의하여,
객체의 행위를 동적으로 바꾸고 싶은 경우 직접 행위를 수정하지 않고 전략을 바꿔주기만 함으로써 행위를 유연하게 확장하는 방법을 말합니다.

오리의 상속관계 구현을 통해 상속의 문제점을 짚는걸로 시작한다.
상속이 재사용 관점에서 사용되다보니, 사이드 이펙트 문제를 낳는다. 이 문제를 해결하기 위해 fly를 추상화하여 구현하는 방식으로 변경하였으나
구현해야할 구현체가 100개 이상이라면 어떻게 할 것인가? 하는 고민을 하게된다. 이 문제를 해결하기위해 협력이라는 관점에서 소유의 개념으로 변경된 코드를 보여주며
소위 "모듈화" 개념을 구현하여 보여주었다. 이렇게 했을때, 변경에는 닫혀있고 확장에는 열려있는 OCP원칙을 지킬 수 있게되었다.
이때 3가지 디자인 원칙을 말하는데 아래와 같다.
1. 애플리케이션에서 달라지는 부분을 찾아내고, 달라지지 않는 부분과 분리한다.
2. 구현보다는 인터페이스에 맞춰서 프로그래밍 한다.
3. 상속보다는 구성을 활용한다. (COMPOSITION)

위와 같이 오리의 행위하나 나누어 알고리즘군을 정의하고 캡슐화여하여 사용하는것 이를 "전략패턴"이라한다.

챕터 2 옵저버 패턴
-
> 한 객체가 상태가 바뀌면 그 객체에 의존하는 다른 객체에게 연락이 가고 자동으로 내용이 갱신되는 방식으로 일대다 의존성을 정의한다.

백화점 식당의 주문현황판을 본적이 있는가? 사용자가 주문하면 해당 하는 주문번호가 생성되고 현황판에 주문대기란에 노출된다.
그러다 식당주인이 요리가 다 되었으면 주문이 다 되었다고 현황판을 업데이트 시킨다. 
이럴때 패턴을 적용시키지 않고 구현한다면, 각 디스플레이마다 상태 업데이트 메세지를 보내야 할 것이다.
그러나 옵저버 패턴은 특정 상태에 대해 변경이 감지 되면 업데이트 되게 한다. 말로는 이해가 잘안된다. 
책에서 구현한 날씨 관련 앱과 응용하여 주문현황판 업데이트 앱을 만들어보자.


