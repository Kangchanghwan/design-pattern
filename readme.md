# 헤드퍼스트의 디자인 패턴


읽은 이유 : 

"오브젝트" 책을 읽은 후에야 디자인 패턴의 의미를 깨달았다. 코딩하면서 디자인 패턴을 자주 썼겠지만, 그게 왜 필요한지 명확히 이해하지 못했다. 
그런데 이 책을 통해 그 이유를 알 수 있게한다.. 이제는 패턴을 무작정 적용하는 게 아니라 상황에 맞게 활용할 줄 알길 원했다., 오픈소스 코드에서도 패턴을 더 잘 파악할 수 있게 될 거 같다.
가장 중요한 건, 디자인 패턴이 코드를 읽기 쉽고 유지 보수하기 쉽게 만들어 준다는 것이다. "오브젝트" 책에서는 이론적인 내용이 많았지만, 객체지향을 다루면서 디자인 패턴을 실제로 적용하는 과정을 배울 수 있어서 기대된다.
결국에는 더 나은 코드를 작성하고 유지 보수할 수 있는 능력을 키울 수 있다는 기대감으로 이 책을 읽는다.


챕터 1 디자인 패턴 소개와 전략 패턴
-
>  객체들이 할 수 있는 행위 각각에 대해 전략 클래스를 생성하고, 유사한 행위들을 캡슐화 하는 인터페이스를 정의하여,
객체의 행위를 동적으로 바꾸고 싶은 경우 직접 행위를 수정하지 않고 전략을 바꿔주기만 함으로써 행위를 유연하게 확장하는 방법을 말합니다.

오리의 상속관계 구현을 통해 상속의 문제점을 짚는걸로 시작한다.
상속이 재사용 관점에서 사용되다보니, 사이드 이펙트 문제를 낳는다. 이 문제를 해결하기 위해 fly를 추상화하여 구현하는 방식으로 변경하였으나
구현해야할 구현체가 100개 이상이라면 어떻게 할 것인가? 하는 고민을 하게된다. 이 문제를 해결하기위해 협력이라는 관점에서 소유의 개념으로 변경된 코드를 보여주며
소위 "모듈화" 개념을 구현하여 보여주었다. 이렇게 했을때, 변경에는 닫혀있고 확장에는 열려있는 OCP원칙을 지킬 수 있게되었다.
이때 3가지 디자인 원칙을 말하는데 아래와 같다.
1. 애플리케이션에서 달라지는 부분을 찾아내고, 달라지지 않는 부분과 분리한다.
2. 구현보다는 인터페이스에 맞춰서 프로그래밍 한다.
3. 상속보다는 구성을 활용한다. (COMPOSITION)

위와 같이 오리의 행위하나 나누어 알고리즘군을 정의하고 캡슐화여하여 사용하는것 이를 "전략패턴"이라한다.

챕터 2 옵저버 패턴
-
> 한 객체가 상태가 바뀌면 그 객체에 의존하는 다른 객체에게 연락이 가고 자동으로 내용이 갱신되는 방식으로 일대다 의존성을 정의한다.

백화점 식당의 주문현황판을 본적이 있는가? 사용자가 주문하면 해당 하는 주문번호가 생성되고 현황판에 주문대기란에 노출된다.
그러다 식당주인이 요리가 다 되었으면 주문이 다 되었다고 현황판을 업데이트 시킨다. 
이럴때 패턴을 적용시키지 않고 구현한다면, 각 디스플레이마다 상태 업데이트 메세지를 보내야 할 것이다.
그러나 옵저버 패턴은 특정 상태에 대해 변경이 감지 되면 업데이트 되게 한다. 말로는 이해가 잘안된다. 
책에서 구현한 날씨 관련 앱과 응용하여 주문현황판 업데이트 앱을 만들어보자.


옵저버 패턴 모양이 생소하다. 이런데도 객체지향의 원칙과 일치하는가? 한번 알아보자

1. 애플리케이션에서 달라지는 부분을 찾아내고, 달라지지 않는 부분과 분리한다. 
-> 옵저버 패턴에서 변하는 것은 주제와 상태 옵저버의 개수, 형식이다.
2. 구현보다는 인터페이스에 맞춰서 프로그래밍 한다.
-> 주제를 Subject로 Observer 인터페이스를 활용하여 구현하였고, 주제는 구독자를 알지 못한다. 즉, 추상화를 의존했다.
3. 상속보다는 구성을 활용한다. (COMPOSITION)
-> 옵저버를 구현한 구현체는 구독할 주제를 has - a 방식인 구성을 이용했다.

옵저버에서도 객체지향 원칙이 잘 지켜지고 있음을 알 수 있다.

챕터 3 객체 꾸미기 데코레이터 패턴
- 
> 객체의 기능을 동적으로 추가하거나 수정할 수 있게 하는 패턴, 이 패턴은 기본적인 객체에 추가적인 기능을 부여하는 역할을 하는 데코레이터 객체를 사용한다. 데코레이터 객체는 원본 객체와 같은 인터페이스를 갖으며, 원본 객체에 추가적인 작업을 추가하거나 오버라이드하여 본질적으로 객체의 행동을 확장합니다.

스타벅스의 음료 메뉴를 예시로 들어 설명해보겠습니다. 스타벅스의 음료 메뉴는 주로 커피나 티를 기본으로 하고, 고객은 여러 옵션을 추가할 수 있습니다. 이때, 상속보다는 데코레이터 패턴을 사용하는 것이 효과적입니다.

데코레이터 패턴은 객체의 행동을 확장하거나 변경할 수 있게 해줍니다. 예를 들어, 아메리카노는 스타벅스의 주요 음료 중 하나입니다. 이를 기본으로 하고, 고객이 시럽을 추가하거나 휘핑 크림을 올릴 수 있습니다.

이 경우, 아메리카노를 나타내는 클래스에는 기본적인 아메리카노의 특성과 행동이 정의됩니다. 그리고 시럽이나 휘핑 크림을 추가하는 것은 데코레이터 클래스로 구현됩니다. 이 데코레이터 클래스는 아메리카노 객체를 소유하고 있으며, 해당 객체에 시럽을 추가하거나 휘핑 크림을 올리는 등의 행동을 정의합니다.

이렇게 하면 기본 객체를 수정하지 않고도 필요한 기능을 추가하거나 변경할 수 있습니다. 또한, 데코레이터 패턴은 중첩되어 여러 옵션을 추가할 수 있으며, 이는 코드를 깔끔하게 유지하면서도 유연성을 제공합니다.

이러한 데코레이터 패턴의 개념은 자바의 IO 스트림에서도 사용됩니다. 예를 들어, FilterInputStream은 추상 데코레이터 클래스로, 이를 상속하여 특정 입력 스트림에 필터를 추가할 수 있습니다. 이를 통해 데이터를 처리하거나 변환하는 등의 작업을 수행할 수 있습니다.

헤드퍼스트의 예제를 보면 Beverage가 추상클래스로 구현되어 있으나 이는 인터페이스로 구현해도 되긴하다.

데코레이터 패턴도 결국 데코레이터 객체를 구현하려면 상속이나 구현을 통해 만들어야하는게 아닌지 의문이 들수 있다.
이는 행동을 상속받으려 한것이 아니라 꾸밀객체의 형식을 상속받은 것임을 명심하자.

문제점
1. 데코레이터가 많아지면 코드가 필요이상으로 복잡해 질 수 있습니다.
2. 클라이언트는 데코레이터를 사용한다는 사실을 전혀모르기때문에 특정형식에 의존한 코드에 적용시 예기치 못한 문제가 발생할 수 있다.



